/*
 Dingoo minimal library by Slaanesh
 Based on Rlyeh's minimal.c for GP2X
 */

#include <ao/ao.h>

ao_device* dingoo_dev_sound;
ao_sample_format format;

static unsigned long dingoo_dev_fb[2] = { 0, 0 };

#ifndef USE_SDL_AUDIO
static unsigned long dingoo_dev_dsp = 0;
#endif

#include "minimal.h"
#include "dingoo_sound.cpp" 
#include "dingoo_cpu.cpp" 
#include "dingoo_keyboard.cpp"

#define KEYBOARD 1

//input
pthread_t pthread_input;
static unsigned long dingoo_dev_gpio = 0;
static unsigned long dingoo_gpioreg = 0;
static bool selectPressed = false;

//screen
unsigned char *dingoo_screen8;
unsigned short *dingoo_screen15;
unsigned int *dingoo_screen32;
int dingoo_sound_rate;
int dingoo_sound_stereo;
int rotate_controls = 0;
unsigned short dingoo_palette[256];

void dingoo_video_flip(void) {
}

void dingoo_video_flip_single(void) {
}

void dingoo_video_setpalette(void) {
}

void dingoo_flush_video(void) {
	// This actually flushes the entire cache in both DCACHE, ICACHE.
	cacheflush((char *) dingoo_screen15, DINGOO_SCREEN_WIDTH
			* DINGOO_SCREEN_HEIGHT * sizeof(unsigned short), DCACHE);
}

//To update dingoo_gpioreg on a separated thread when the events are created
void* read_events(void* param) {
	dingoo_dev_gpio = open("/dev/event0", O_RDWR);
	input_event ie;
	while (read(dingoo_dev_gpio, &ie, sizeof(input_event))) {
		unsigned long flag = 0;
		switch (ie.code) {
		case KEY_UP:
			flag = DINGOO_UP;
			break;
		case KEY_DOWN:
			flag = DINGOO_DOWN;
			break;
		case KEY_LEFT:
			flag = DINGOO_LEFT;
			break;
		case KEY_RIGHT:
			flag = DINGOO_RIGHT;
			break;
		case KEY_LEFTCTRL:
			flag = DINGOO_A;
			break;
		case KEY_LEFTALT:
			flag = DINGOO_B;
			break;
		case KEY_SPACE:
			flag = DINGOO_X;
			break;
		case KEY_LEFTSHIFT:
			flag = DINGOO_Y;
			break;
		case KEY_TAB:
			flag = DINGOO_L;
			break;
		case KEY_BACKSPACE:
			flag = DINGOO_R;
			break;
		case KEY_ENTER:
			flag = DINGOO_START;
			break;
		case KEY_ESC:
			flag = DINGOO_SELECT;
			break;
		case KEY_POWER:
			flag = DINGOO_POWER;
			break;
		}
		switch (ie.value) {
		case 0: //key released
			dingoo_gpioreg &= ~flag;
			if (flag == DINGOO_SELECT)
				selectPressed = false;
			break;
		case 1: //key pressed
			dingoo_gpioreg |= flag;
			if (flag == DINGOO_SELECT)
				selectPressed = true;
			break;
		}
	}
}

void dingoo_release_power_slider() {
	dingoo_gpioreg &= ~DINGOO_POWER;
}

unsigned long dingoo_joystick_read(unsigned int use_virtual) {
	unsigned long reg = dingoo_gpioreg;
	/* If using virtual keys, check whether SELECT is being pressed */
	if (use_virtual && selectPressed) {
		reg |= (reg & MASK_SEL_SHIFT) << 7;
		reg &= ~DINGOO_SELECT; /* remove SELECT */
	}
	return reg;
}

void dingoo_joystick_press(void) {
	while (!dingoo_joystick_read(1))
		;
}

void dingoo_sound_volume(int l, int r) { //useless, power+up or power+down to change volume in opendingux
	// TODO: Fix this external dependency
	//extern int master_volume;
	//l=l<0?0:l; l=l>319?319:l; r=r<0?0:r; r=r>319?319:r;
	//l=(((l*0x50)/100)<<8)|((r*0x50)/100); /*0x5A, 0x60*/
	//l=l<0?0:l; l=l>100?100:l; r=r<0?0:r; r=r>100?100:r;
	//if (l>0) master_volume=l;	/* Dont set if muting */
	//l=(l<<8)|r;
	//ioctl(dingoo_dev_mixer, SOUND_MIXER_WRITE_VOLUME, &l);
	//ioctl(dingoo_dev_mixer, SOUND_MIXER_WRITE_PCM, &l); /*SOUND_MIXER_WRITE_VOLUME*/
}

int dingoo_get_capacity() {
	FILE *file;
	int mvolts = 0;
	file = fopen("/sys/class/power_supply/battery/capacity", "r");
	if (file) {
		fscanf(file,"%d",&mvolts);
		fclose(file);
	}
	return mvolts;
}

void dingoo_set_brightness(int value) { //useless, power+right or power+left to change the brightness (opendingux

}

void dingoo_timer_delay(clock_t milliseconds) {
	clock_t now = dingoo_timer_read();
	while (dingoo_timer_read() - now < (milliseconds))
		;
}

clock_t dingoo_timer_read(void) {
	return clock(); /* CLOCKS_PER_SEC = 1000000 */
}

void dingoo_timer_profile(void) {
}

void dingoo_init(int rate, int bits, int stereo, unsigned int mhz, unsigned int brightness) {
	int frag;

	//Init input
#if KEYBOARD
	OpenKeyboard();
	EnterGraphicsMode();
#endif

	pthread_create(&pthread_input, NULL, read_events, NULL);

	//Init audio
#ifndef USE_SDL_AUDIO

	dingoo_sound_rate = rate;
	dingoo_sound_stereo = stereo;

	ao_initialize();

	memset(&format, 0, sizeof(format));

	format.bits = bits;
	format.channels = stereo+1;
	format.rate = rate;
	format.byte_format = AO_FMT_LITTLE;

	dingoo_dev_sound = ao_open_live(ao_default_driver_id(), &format, NULL);

	if (dingoo_dev_sound == NULL) {
		fprintf(stderr, "Error opening device.\n");
	}
#endif

	/* sound volume */
	dingoo_sound_volume(90, 90);

	//Init video
	dingoo_dev_fb[0] = open("/dev/fb0", O_RDWR);

	/* map framebuffer to write to video */
	dingoo_screen15 = (unsigned short *) mmap(0, DINGOO_SCREEN_WIDTH
			* DINGOO_SCREEN_HEIGHT * sizeof(unsigned short), PROT_WRITE,
			MAP_SHARED, dingoo_dev_fb[0], 0);
	if (dingoo_screen15 == MAP_FAILED) {
		printf("mmap for dingoo_screen15 failed\n");
		exit(1);
	}
	dingoo_screen8 = (unsigned char *) dingoo_screen15; /* no 8-bit screen */
	dingoo_screen32 = (unsigned int *) dingoo_screen15;

	/* clear screen */
	dingoo_clear_video();

	/* set dingoo screen brightness */
	dingoo_set_brightness(brightness);

	/* set dingoo cpu speed */
	if (mhz != DINGOO_DEFAULT_MHZ) {
		dingoo_set_clock(mhz);
	}
}

#if defined(__cplusplus)
extern "C" {
#endif
extern int fcloseall(void);
#if defined(__cplusplus)
}
#endif

void dingoo_deinit(void) {
	//dingoo_set_clock(336);	/* default speed */

	dingoo_clear_video();

#if KEYBOARD
	CloseKeyboard();
	LeaveGraphicsMode();
#endif

	/* close devices */
	/* unmap framebuffer */
	munmap((void *) dingoo_screen15, DINGOO_SCREEN_WIDTH * DINGOO_SCREEN_HEIGHT
			* sizeof(unsigned short));

#ifndef USE_SDL_AUDIO
	dingoo_sound_thread_stop();
	ao_close(dingoo_dev_sound);
#endif

	close(dingoo_dev_fb[0]);

	pthread_cancel(pthread_input); //TODO send something to the thread and let it finish by itself
	close(dingoo_dev_gpio); //TODO this should be inside the thread function

	fcloseall();
}

void dingoo_set_video_mode(int bpp, int width, int height) {
	dingoo_clear_video();

	/*
	 * Not much else to do here as we're are always using
	 * a 320 x 240 x 16bit screen
	 */
}

void dingoo_video_wait_vsync(void) {
	/* Looks like this is impossible with the Dingoo's LCD */
	/* TV out uses the built in controller so it may be useful for that */
}

void dingoo_clear_video(void) {
	// Clear to black
	memset(dingoo_screen15, 0x0, DINGOO_SCREEN_WIDTH * DINGOO_SCREEN_HEIGHT
			* sizeof(unsigned short));
}

static unsigned char fontdata8x8[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x3C, 0x42, 0x99, 0xBD, 0xBD, 0x99, 0x42, 0x3C, 0x3C, 0x42,
		0x81, 0x81, 0x81, 0x81, 0x42, 0x3C, 0xFE, 0x82, 0x8A, 0xD2, 0xA2, 0x82,
		0xFE, 0x00, 0xFE, 0x82, 0x82, 0x82, 0x82, 0x82, 0xFE, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x64, 0x74, 0x7C, 0x38,
		0x00, 0x00, 0x80, 0xC0, 0xF0, 0xFC, 0xF0, 0xC0, 0x80, 0x00, 0x01, 0x03,
		0x0F, 0x3F, 0x0F, 0x03, 0x01, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x7E, 0x3C,
		0x18, 0x00, 0xEE, 0xEE, 0xEE, 0xCC, 0x00, 0xCC, 0xCC, 0x00, 0x00, 0x00,
		0x30, 0x68, 0x78, 0x30, 0x00, 0x00, 0x00, 0x38, 0x64, 0x74, 0x7C, 0x38,
		0x00, 0x00, 0x3C, 0x66, 0x7A, 0x7A, 0x7E, 0x7E, 0x3C, 0x00, 0x0E, 0x3E,
		0x3A, 0x22, 0x26, 0x6E, 0xE4, 0x40, 0x18, 0x3C, 0x7E, 0x3C, 0x3C, 0x3C,
		0x3C, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x7E, 0x3C, 0x18, 0x00, 0x08, 0x7C,
		0x7E, 0x7E, 0x7C, 0x08, 0x00, 0x00, 0x10, 0x3E, 0x7E, 0x7E, 0x3E, 0x10,
		0x00, 0x00, 0x58, 0x2A, 0xDC, 0xC8, 0xDC, 0x2A, 0x58, 0x00, 0x24, 0x66,
		0xFF, 0xFF, 0x66, 0x24, 0x00, 0x00, 0x00, 0x10, 0x10, 0x38, 0x38, 0x7C,
		0xFE, 0x00, 0xFE, 0x7C, 0x38, 0x38, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x1C, 0x1C, 0x18, 0x00, 0x18,
		0x18, 0x00, 0x6C, 0x6C, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28,
		0x7C, 0x28, 0x7C, 0x28, 0x00, 0x00, 0x10, 0x38, 0x60, 0x38, 0x0C, 0x78,
		0x10, 0x00, 0x40, 0xA4, 0x48, 0x10, 0x24, 0x4A, 0x04, 0x00, 0x18, 0x34,
		0x18, 0x3A, 0x6C, 0x66, 0x3A, 0x00, 0x18, 0x18, 0x20, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x30, 0x60, 0x60, 0x60, 0x60, 0x60, 0x30, 0x00, 0x0C, 0x06,
		0x06, 0x06, 0x06, 0x06, 0x0C, 0x00, 0x10, 0x54, 0x38, 0x7C, 0x38, 0x54,
		0x10, 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x04,
		0x08, 0x10, 0x20, 0x40, 0x00, 0x00, 0x38, 0x4C, 0xC6, 0xC6, 0xC6, 0x64,
		0x38, 0x00, 0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x7C, 0xC6,
		0x0E, 0x3C, 0x78, 0xE0, 0xFE, 0x00, 0x7E, 0x0C, 0x18, 0x3C, 0x06, 0xC6,
		0x7C, 0x00, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x0C, 0x00, 0xFC, 0xC0,
		0xFC, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x3C, 0x60, 0xC0, 0xFC, 0xC6, 0xC6,
		0x7C, 0x00, 0xFE, 0xC6, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00, 0x78, 0xC4,
		0xE4, 0x78, 0x86, 0x86, 0x7C, 0x00, 0x7C, 0xC6, 0xC6, 0x7E, 0x06, 0x0C,
		0x78, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00,
		0x18, 0x00, 0x00, 0x18, 0x18, 0x30, 0x1C, 0x38, 0x70, 0xE0, 0x70, 0x38,
		0x1C, 0x00, 0x00, 0x7C, 0x00, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x70, 0x38,
		0x1C, 0x0E, 0x1C, 0x38, 0x70, 0x00, 0x7C, 0xC6, 0xC6, 0x1C, 0x18, 0x00,
		0x18, 0x00, 0x3C, 0x42, 0x99, 0xA1, 0xA5, 0x99, 0x42, 0x3C, 0x38, 0x6C,
		0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0x00, 0xFC, 0xC6, 0xC6, 0xFC, 0xC6, 0xC6,
		0xFC, 0x00, 0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00, 0xF8, 0xCC,
		0xC6, 0xC6, 0xC6, 0xCC, 0xF8, 0x00, 0xFE, 0xC0, 0xC0, 0xFC, 0xC0, 0xC0,
		0xFE, 0x00, 0xFE, 0xC0, 0xC0, 0xFC, 0xC0, 0xC0, 0xC0, 0x00, 0x3E, 0x60,
		0xC0, 0xCE, 0xC6, 0x66, 0x3E, 0x00, 0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6,
		0xC6, 0x00, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x06, 0x06,
		0x06, 0x06, 0xC6, 0xC6, 0x7C, 0x00, 0xC6, 0xCC, 0xD8, 0xF0, 0xF8, 0xDC,
		0xCE, 0x00, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00, 0xC6, 0xEE,
		0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0x00, 0xC6, 0xE6, 0xF6, 0xFE, 0xDE, 0xCE,
		0xC6, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0xFC, 0xC6,
		0xC6, 0xC6, 0xFC, 0xC0, 0xC0, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xDE, 0xCC,
		0x7A, 0x00, 0xFC, 0xC6, 0xC6, 0xCE, 0xF8, 0xDC, 0xCE, 0x00, 0x78, 0xCC,
		0xC0, 0x7C, 0x06, 0xC6, 0x7C, 0x00, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18,
		0x18, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0xC6, 0xC6,
		0xC6, 0xEE, 0x7C, 0x38, 0x10, 0x00, 0xC6, 0xC6, 0xD6, 0xFE, 0xFE, 0xEE,
		0xC6, 0x00, 0xC6, 0xEE, 0x3C, 0x38, 0x7C, 0xEE, 0xC6, 0x00, 0x66, 0x66,
		0x66, 0x3C, 0x18, 0x18, 0x18, 0x00, 0xFE, 0x0E, 0x1C, 0x38, 0x70, 0xE0,
		0xFE, 0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x60, 0x60,
		0x30, 0x18, 0x0C, 0x06, 0x06, 0x00, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
		0x3C, 0x00, 0x18, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x30, 0x30, 0x18, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x66, 0x3C, 0x00, 0x60, 0x7C,
		0x66, 0x66, 0x66, 0x66, 0x7C, 0x00, 0x00, 0x3C, 0x66, 0x60, 0x60, 0x66,
		0x3C, 0x00, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00, 0x00, 0x3C,
		0x66, 0x66, 0x7E, 0x60, 0x3C, 0x00, 0x1C, 0x30, 0x78, 0x30, 0x30, 0x30,
		0x30, 0x00, 0x00, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x3C, 0x60, 0x7C,
		0x76, 0x66, 0x66, 0x66, 0x66, 0x00, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18,
		0x18, 0x00, 0x0C, 0x00, 0x1C, 0x0C, 0x0C, 0x0C, 0x0C, 0x38, 0x60, 0x60,
		0x66, 0x6C, 0x78, 0x6C, 0x66, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18,
		0x18, 0x00, 0x00, 0xEC, 0xFE, 0xFE, 0xFE, 0xD6, 0xC6, 0x00, 0x00, 0x7C,
		0x76, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66,
		0x3C, 0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x00, 0x3E,
		0x66, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x00, 0x7E, 0x70, 0x60, 0x60, 0x60,
		0x60, 0x00, 0x00, 0x3C, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00, 0x30, 0x78,
		0x30, 0x30, 0x30, 0x30, 0x1C, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x6E,
		0x3E, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00, 0x00, 0xC6,
		0xD6, 0xFE, 0xFE, 0x7C, 0x6C, 0x00, 0x00, 0x66, 0x3C, 0x18, 0x3C, 0x66,
		0x66, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x3C, 0x00, 0x7E,
		0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00, 0x0E, 0x18, 0x0C, 0x38, 0x0C, 0x18,
		0x0E, 0x00, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00, 0x70, 0x18,
		0x30, 0x1C, 0x30, 0x18, 0x70, 0x00, 0x00, 0x00, 0x76, 0xDC, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x28, 0x10, 0x54, 0xAA, 0x44, 0x00, 0x00, };

static void dingoo_text(unsigned short *screen, int x, int y, char *text,
		int color) {
	unsigned int i, l;
	screen = screen + x + y * DINGOO_SCREEN_WIDTH;

	for (i = 0; i < strlen(text); i++) {
		for (l = 0; l < 8; l++) {
			screen[l * DINGOO_SCREEN_WIDTH + 0] = (fontdata8x8[((text[i]) * 8)
					+ l] & 0x80) ? color : screen[l * DINGOO_SCREEN_WIDTH + 0];
			screen[l * DINGOO_SCREEN_WIDTH + 1] = (fontdata8x8[((text[i]) * 8)
					+ l] & 0x40) ? color : screen[l * DINGOO_SCREEN_WIDTH + 1];
			screen[l * DINGOO_SCREEN_WIDTH + 2] = (fontdata8x8[((text[i]) * 8)
					+ l] & 0x20) ? color : screen[l * DINGOO_SCREEN_WIDTH + 2];
			screen[l * DINGOO_SCREEN_WIDTH + 3] = (fontdata8x8[((text[i]) * 8)
					+ l] & 0x10) ? color : screen[l * DINGOO_SCREEN_WIDTH + 3];
			screen[l * DINGOO_SCREEN_WIDTH + 4] = (fontdata8x8[((text[i]) * 8)
					+ l] & 0x08) ? color : screen[l * DINGOO_SCREEN_WIDTH + 4];
			screen[l * DINGOO_SCREEN_WIDTH + 5] = (fontdata8x8[((text[i]) * 8)
					+ l] & 0x04) ? color : screen[l * DINGOO_SCREEN_WIDTH + 5];
			screen[l * DINGOO_SCREEN_WIDTH + 6] = (fontdata8x8[((text[i]) * 8)
					+ l] & 0x02) ? color : screen[l * DINGOO_SCREEN_WIDTH + 6];
			screen[l * DINGOO_SCREEN_WIDTH + 7] = (fontdata8x8[((text[i]) * 8)
					+ l] & 0x01) ? color : screen[l * DINGOO_SCREEN_WIDTH + 7];
		}
		screen += 8;
	}
}

void dingoo_gamelist_text_out(int x, int y, char *eltexto) {
	char texto[33];
	strncpy(texto, eltexto, 32);
	texto[32] = 0;
	if (texto[0] != '-')
		dingoo_text(dingoo_screen15, x + 1, y + 1, texto, DINGOO_BLACK);
	dingoo_text(dingoo_screen15, x, y, texto, DINGOO_WHITE);
}

/* Variadic functions guide found at http://www.unixpapa.com/incnote/variadic.html */
void dingoo_gamelist_text_out_fmt(int x, int y, char* fmt, ...) {
	char strOut[128];
	va_list marker;

	va_start(marker, fmt);
	vsprintf(strOut, fmt, marker);
	va_end(marker);

	dingoo_gamelist_text_out(x, y, strOut);
}

static int log = 0;

void dingoo_printf_init(void) {
	log = 0;
}

static void dingoo_text_log(char *texto) {
	if (!log) {
		dingoo_clear_video();
	}
	dingoo_text(dingoo_screen15, 0, log, texto, DINGOO_WHITE);
	log += 8;
	if (log > 239)
		log = 0;
}

/* Variadic functions guide found at http://www.unixpapa.com/incnote/variadic.html */
void dingoo_printf(char* fmt, ...) {
	unsigned int i, c;
	char strOut[4096];
	char str[41];
	va_list marker;

	va_start(marker, fmt);
	vsprintf(strOut, fmt, marker);
	va_end(marker);

	c = 0;
	for (i = 0; i < strlen(strOut); i++) {
		str[c] = strOut[i];
		if (str[c] == '\n') {
			str[c] = 0;
			dingoo_text_log(str);
			c = 0;
		} else if (c == 39) {
			str[40] = 0;
			dingoo_text_log(str);
			c = 0;
		} else {
			c++;
		}
	}
}

